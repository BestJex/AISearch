h1 class title-article 重叠 时间段 问题 优化 算法 详解 h1 目录 一 问题 提出 1. 描述 2. 分析 二 优化 重叠 查询 1. 自 关联 2. 游标 内存 临时 表 三 改进 取得 活跃 时段 的 算法 1. 最小 范围 算法 表 连接 2. 正负 计数器 算法 一次 扫描 四 mysql 8 的 单 条 查询 解决方案 一 问题 提出 1. 描述 nbsp nbsp nbsp nbsp 这是 一个 实际 业务 需求 中 的 问题 某一 直播 业务 表 中 记录 了如 下 格式 的 用户 进出 直播 间 日志 数据 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 10 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 10 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 01 03 2018-01-03 01 11 01 nbsp nbsp nbsp 2 nbsp nbsp nbsp 4 2018-01-01 01 03 02 2018-01-01 01 12 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 5 2018-01-01 01 11 02 2018-01-01 01 12 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 6 2018-01-01 01 15 02 2018-01-01 01 16 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 7 2018-01-01 01 01 03 2018-01-01 01 11 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 8 2018-01-01 23 01 03 2018-01-02 01 11 01 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-05 01 01 01 2018-01-10 01 01 01 nbsp nbsp nbsp 3 nbsp nbsp nbsp 2 2018-01-05 01 01 01 2018-01-06 01 01 01 nbsp nbsp nbsp 3 nbsp nbsp nbsp 3 2018-01-06 01 01 01 2018-01-06 02 01 01 nbsp nbsp nbsp nbsp 四个 字段 分别 表示 直播 间 id 用户 id 进入 时间 和 退出 时间 求 每天 每个 活跃 房间 的 峰值 人数 和 总 时长 活跃 房间 的 定义 是 以 每秒 为 时间 粒度 如果在 某一 时刻 同时 有 两个 及其 以上 的 用户 在 房间内 该 房间 当天 即为 活跃 房间 峰值 人数 是 指 一 天内 同时 在 一个 活跃 房间 的 最大 人数 总 活跃 时长 是 指 一 天内 活跃 时长 的 总和 2. 分析 nbsp nbsp nbsp nbsp 这是 一个 典型 的 重叠 时间段 的 统计 问题 具体来说 该 需求 可以 细 分为 这样 几个 需要 解决 的 问题 一个 房间内 同一 用户 的 重叠 时间段 合并 拆分 起止 时间段 跨 天 的 时段 取得 活跃 的 时段 按 天 计算 每个 房间 活跃 时段 内 的 不同 用户数 及其 活跃 时段 的 长度 选取 活跃 时段 内 的 最大 人数 并 汇总 活跃 时长 1 一个 房间内 同一 用户 的 重叠 时段 问题 nbsp nbsp nbsp nbsp 理论上 同一 用户 进出 房间 的 时间段 是 不存在 重叠 的 但 表 数据 是 移动 端 程序 上报 的 做过 移动 应用 的 开发者 应该 都 理解 类似 数据 统计 类 的 需求 不能 直接 依赖 端 上报 的 数据 因为 有 各种 原因 造成 上报 数据 不 准确 此 案例 中 任意 给定 的 一个 房间 用户 在 其内 的 时间 存在 重叠 部分 而 重叠 又分 同一 用户 的 重叠 与 不同 用户 之间 重叠 两种 情况 对于 前一种 情况 在 判断 房间 是否 活跃 时 不应该 对 用户 重复 计数 因此 这 部分 的 重叠 时段 需要 进行 合并 例如 2018-01-01 日 用户 1 在 房间 1 有 四条 日志 记录 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 10 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 10 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp nbsp nbsp 为了 判断 房间 1 在 2018-01-01 01 01 01 和 2018-01-01 01 11 05 之间 是否 存在 活跃 时间段 需 要将 四条 记录 合 并为 如下 两条 记录 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 2 起止 时段 跨 天 的 问题 nbsp nbsp nbsp nbsp 由 于是 按 天 进行 统计 对于 进出 时间 点 跨 天 的 情况 要 进行 拆分 例如 用户 1 在 房间 2 的 进出 时间 跨越 了 三天 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 01 03 2018-01-03 01 11 01 nbsp nbsp nbsp nbsp 为了 统计 2018-01-01 2018-01-02 2018-01-03 三天 的 数据 需 要将 这条 记录 拆 分为 如下 三条 记录 roomid userid nbsp nbsp nbsp nbsp nbsp s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 01 03 2018-01-01 23 59 59 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-02 00 00 00 2018-01-02 23 59 59 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-03 00 00 00 2018-01-03 01 11 01 nbsp nbsp nbsp nbsp 拆分 的 起止 时间 相差 一秒 不能 相同 在后面 介绍 计算 活跃 时间段 内 的 不同 用户数 及其 活跃 时长 的 算法 时 会 看到 这点 非常重要 3 统计 活跃 时段 nbsp nbsp nbsp nbsp 经 过了 前 两步 的 数据 预处理 便 可以 统计 活跃 时段 这 步 是 一个 令人 头疼 的 问题 关键在于 如何 高效 地 获取 活跃 时段 我们 尝 试了 多种 解决方案 后面 将 介绍 其中 两种 它们 的 性能 有着 天壤之别 nbsp nbsp nbsp nbsp 下面 建立 测 试表 并 生成 数据 用于 演示 各种 sql 的 执行 结果 create table test1 roomid int userid int s datetime e datetime insert into test1 values 1 1 2018-01-01 01 01 01 2018-01-01 01 10 01 1 2 2018-01-01 01 01 02 2018-01-01 01 01 05 1 3 2018-01-01 01 01 05 2018-01-01 01 02 05 2 4 2018-01-01 01 03 02 2018-01-01 01 12 05 2 5 2018-01-01 01 11 02 2018-01-01 01 12 05 2 6 2018-01-01 01 15 02 2018-01-01 01 16 05 2 7 2018-01-01 01 01 03 2018-01-01 01 11 05 1 1 2018-01-01 01 01 05 2018-01-01 01 10 01 1 1 2018-01-01 01 01 02 2018-01-01 01 11 01 1 1 2018-01-01 01 11 02 2018-01-01 01 11 05 2 1 2018-01-01 01 01 03 2018-01-03 01 11 01 2 8 2018-01-01 23 01 03 2018-01-02 01 11 01 3 1 2018-01-05 01 01 01 2018-01-10 01 01 01 3 2 2018-01-05 01 01 01 2018-01-06 01 01 01 3 3 2018-01-06 01 01 01 2018-01-06 02 01 01 commit nbsp nbsp nbsp nbsp 为了 验证 不同 方案 的 在 实际 数据 集 上 的 执行 性能 采 集了 三天 的 2505495条 业务 数据 存储 在 u_room_log 表 中 u_room_log 与 test1 表 结构 相同 并且 都没有 任何 索引 二 优化 重叠 查询 nbsp nbsp nbsp nbsp 如前所述 我们 需要 解决 的 第一个 问题 时 合并 一个 房间内 同一 用户 的 重叠 时间段 下面 讨论 两种 自 关联 和 游标 实现 方案 1. 自 关联 nbsp nbsp nbsp nbsp 重叠 问题 的 sql 解决方案 中 最 容易 想到 的 是 自 关联 先 求出 每个 分组 的 开始 时间 并用 distinct 返 回去 重 然 后用 同样 的 方法 得到 每组 结束 的 时间 最后 把 前 两步 的 结果 集 合并 并 通过 min 函数 取得 结束 的 时间 完整 的 sql 解决方案 如下 面的 代码 所示 select distinct roomid userid nbsp nbsp nbsp nbsp nbsp if date s date e and id&gt 1 date s+interval id-1 day s s nbsp nbsp nbsp nbsp nbsp if date s+interval id-1 day date e e date_format s+interval id-1 day y- m- d 23 59 59 e nbsp nbsp from select distinct s.roomid s.userid s.s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select min e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 合并 后 每个 区间 的 结束 时间 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select distinct roomid userid e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from test1 a nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where not exists select from test1 b nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where a.roomid b.roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.userid b.userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.e gt b.s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.e lt b.e s2 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where s2.e gt s.s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and s.roomid s2.roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and s.userid s2.userid e nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select distinct roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp 每个 房间 每个 用户 的 开始 时间 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from test1 a nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where not exists select from test1 b nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where a.roomid b.roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.userid b.userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.s gt b.s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.s lt b.e s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select distinct roomid userid e nbsp nbsp nbsp nbsp nbsp nbsp nbsp 每个 房间 每个 用户 的 结束 时间 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from test1 a nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where not exists select from test1 b nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where a.roomid b.roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.userid b.userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.e gt b.s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and a.e lt b.e e nbsp nbsp nbsp nbsp nbsp nbsp nbsp where s.roomid e.roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and s.userid e.userid t1 nbsp nbsp nbsp nbsp nbsp select id from nums where id&lt 100 nums nbsp nbsp where nums.id&lt datediff e s 1 nbsp nbsp nbsp nbsp 最 外层 的 查询 用于 处理 跨 天 时段 关联 数字 辅助 表 将 单行 数据 分解为 多行 id&lt 100 表示 单个 时段 跨越 的 天数 最 多是 100 对于 按 天 统计 的 直播 业务 这个 跨度 足 够了 为了 提高 查询 性能 该 值 应 该为 满足 需求 的 最小值 下面 是 该 查询 的 执行 结果 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 4 2018-01-01 01 03 02 2018-01-01 01 12 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 5 2018-01-01 01 11 02 2018-01-01 01 12 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 6 2018-01-01 01 15 02 2018-01-01 01 16 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 7 2018-01-01 01 01 03 2018-01-01 01 11 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 01 03 2018-01-01 23 59 59 nbsp nbsp nbsp 2 nbsp nbsp nbsp 8 2018-01-01 23 01 03 2018-01-01 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-05 01 01 01 2018-01-05 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 2 2018-01-05 01 01 01 2018-01-05 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 3 2018-01-06 01 01 01 2018-01-06 02 01 01 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-02 00 00 00 2018-01-02 23 59 59 nbsp nbsp nbsp 2 nbsp nbsp nbsp 8 2018-01-02 00 00 00 2018-01-02 01 11 01 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-06 00 00 00 2018-01-06 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 2 2018-01-06 00 00 00 2018-01-06 01 01 01 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-03 00 00 00 2018-01-03 01 11 01 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-07 00 00 00 2018-01-07 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-08 00 00 00 2018-01-08 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-09 00 00 00 2018-01-09 23 59 59 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-10 00 00 00 2018-01-10 01 01 01 22 rows in set 0.01 sec nbsp nbsp nbsp nbsp 原 表 的 15行 数据 经过 重叠 合 并与 跨 天 拆分 后 变为 22条 数据 自 关联 的 写法 比较 易懂 在 小 数据 集 上 的 性能 尚可 但 如果 表 很大 这种 写法 就会 凸显 性能 问题 将 查询 中 的 test1 表 改为 u_room_log 表 没有 等到 出 结果 慢 的 原因 从 查询 计划 中就 可得到 直观 反映 id select_type nbsp nbsp nbsp nbsp table nbsp nbsp nbsp partitions type nbsp possible_keys key nbsp nbsp nbsp nbsp key_len ref nbsp nbsp nbsp nbsp nbsp nbsp nbsp rows nbsp nbsp filtered extra nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 primary nbsp nbsp nbsp nbsp nbsp nbsp nums nbsp nbsp nbsp null nbsp nbsp nbsp range primary nbsp nbsp nbsp primary nbsp nbsp 8 nbsp nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 100 nbsp 100.00 using where using index using temporary nbsp nbsp nbsp nbsp nbsp nbsp 1 primary nbsp nbsp nbsp nbsp nbsp nbsp lt derived2&gt null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp 24980980 nbsp 100.00 using where using join buffer block nested loop nbsp 2 derived nbsp nbsp nbsp nbsp nbsp nbsp lt derived6&gt null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp 100.00 using where using temporary nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2 derived nbsp nbsp nbsp nbsp nbsp nbsp lt derived8&gt null nbsp nbsp nbsp ref nbsp lt auto_key0&gt nbsp lt auto_key0&gt 14 nbsp nbsp nbsp s.roomid s.userid nbsp nbsp nbsp 10 nbsp 100.00 distinct nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 8 derived nbsp nbsp nbsp nbsp nbsp nbsp a nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp 100.00 using where using temporary nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 9 dependent subquery b nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp nbsp 0.11 using where nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 6 derived nbsp nbsp nbsp nbsp nbsp nbsp a nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp 100.00 using where using temporary nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 7 dependent subquery b nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp nbsp 0.11 using where nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 3 dependent subquery lt derived4&gt null nbsp nbsp nbsp ref nbsp lt auto_key0&gt nbsp lt auto_key0&gt 14 nbsp nbsp nbsp s.roomid s.userid nbsp 249809 nbsp nbsp 33.33 using where using index nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 4 derived nbsp nbsp nbsp nbsp nbsp nbsp a nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp 100.00 using where using temporary nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 5 dependent subquery b nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2498089 nbsp nbsp 0.11 using where nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 要对 一个 250 万行 的 表 多次 进行 相 关子 查询 总计 要 扫描 的 行数 是 多个 250万 的 乘积 从 执行时间 看 基本 没有意义 因此 这个 写法 被 否定 了 我们 希望 找到 只 扫描 一遍 表 的 实现 方法 这是 最优 的 解决方案 因为 无论如何 也要 扫描 一遍 表 2. 游标 内存 临时 表 nbsp nbsp nbsp nbsp 在 数据库 优化 中有 一条 基本原则 就是 尽量 使用 集合 操作 而 避免 使用 游标 来看 一个 最 简单 的 例子 nums 是 单列 100 万行 的 数字 辅助 表 select 查询 时间 为 0.41秒 mysql&gt select id id from nums 1000000 rows in set 1 warning 0.41 sec 而 游标 遍历 的 时间 为 3.05秒 比 单 条 select 语句 慢了 7.4倍 mysql&gt delimiter mysql&gt create procedure p_cursor gt begin gt declare done int default 0 gt declare v_id bigint gt gt declare cur_nums cursor for select id from nums gt declare continue handler for not found set done 1 gt gt open cur_nums gt repeat gt fetch cur_nums into v_id gt until done end repeat gt close cur_nums gt end query ok 0 rows affected 0.01 sec mysql&gt mysql&gt call p_cursor query ok 0 rows affected 3.05 sec nbsp nbsp nbsp nbsp 此 案例 中 情况 却 有所不同 有 可能 通过 业务 数据表 上 的 游标 在 逐行 遍历 表 时 编写 复杂 的 应用逻辑 避免 大 表 之间 的 关联 极大 减少 扫描 行数 性能 会比 表 关联 好 很多 下面 是 用 游标 合并 重叠 时间段 的 存储 过程 drop procedure if exists sp_overlap delimiter create procedure sp_overlap nbsp begin nbsp nbsp nbsp declare done int default 0 nbsp nbsp nbsp nbsp nbsp declare v_roomid bigint nbsp nbsp nbsp declare v_userid bigint nbsp nbsp nbsp nbsp nbsp declare v_start datetime nbsp nbsp nbsp declare v_end datetime nbsp nbsp nbsp declare v_prev_roomid int nbsp nbsp nbsp declare v_prev_userid bigint nbsp nbsp nbsp declare v_max_end datetime nbsp nbsp nbsp nbsp nbsp declare cur_t1 cursor for select roomid userid s e from test1 order by roomid userid s e nbsp nbsp nbsp nbsp nbsp declare continue handler for not found set done 1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp drop table if exists t nbsp nbsp nbsp drop table if exists t1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp drop table if exists tmp_s nbsp nbsp nbsp nbsp nbsp create temporary table t nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp userid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp s datetime nbsp nbsp nbsp nbsp nbsp nbsp nbsp e datetime nbsp nbsp nbsp nbsp nbsp nbsp nbsp broken int nbsp nbsp nbsp nbsp nbsp engine memory nbsp nbsp nbsp nbsp nbsp nbsp create temporary table t1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid int nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp userid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp s datetime nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e datetime nbsp nbsp engine memory nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp create temporary table tmp_s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp userid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp s datetime nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e datetime nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp i int nbsp nbsp nbsp nbsp nbsp nbsp engine memory nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp open cur_t1 nbsp nbsp nbsp nbsp nbsp nbsp repeat nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp fetch cur_t1 into v_roomid v_userid v_start v_end nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp if done 1 then nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp if v_roomid v_prev_roomid and v_userid v_prev_userid then nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp if v_start&lt v_max_end then nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into t values v_roomid v_userid v_start v_end 0 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp else nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into t values v_roomid v_userid v_start v_end 1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp end if nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp if v_end&gt v_max_end then nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp set v_max_end v_end nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp end if nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp set v_prev_roomid v_roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp set v_userid v_userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp else nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp set v_max_end v_end nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp set v_prev_roomid v_roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp set v_prev_userid v_userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into t values v_roomid v_userid v_start v_end 1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp end if nbsp nbsp nbsp nbsp nbsp end if nbsp nbsp nbsp nbsp nbsp until done end repeat nbsp nbsp nbsp nbsp nbsp nbsp close cur_t1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into tmp_s nbsp nbsp nbsp select roomid userid min s s max e e datediff max e min s 1 i nbsp nbsp nbsp nbsp nbsp from select roomid userid s e case when flag flag then rn rn+broken when flag flag then rn broken end ran&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select roomid userid s e broken concat roomid userid flag from t select flag rn 0 vars a&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp order by roomid userid s e b nbsp nbsp nbsp nbsp nbsp group by roomid userid ran nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select max i into c from tmp_s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into t1 roomid userid s e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp if date s date e and id&gt 1 date s+interval id-1 day s s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp if date s+interval id-1 day date e e date_format s+interval id-1 day y- m- d 23 59 59 e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from tmp_s t1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp select id from nums where id&lt c nums&nbsp nbsp nbsp nbsp where nums.id&lt t1.i end nbsp nbsp nbsp nbsp 定义 游标 的 查询 需 要按 房间 id 用户 id 起始 时间 终止 时间 排序 v_roomid v_userid v_start v_end 四个 变量 存储 游标 当 前行 四个 字段 的 数据 由于 要按 房间 和 用户 分组 v_prev_roomid 与 v_prev_userid 分别 存储 前 一行 的 房间 id 和 用户 id 用于 和 当前 行 进行 比较 判断 哪些 行 属于 同一 组 nbsp nbsp nbsp nbsp v_max_end 变量 存储 同一 分组 中 当前 最大 的 结束 时间 在当 前行 的 开始 时间 小于 等于 v_max_end 时 说明 当 前行 与 同组 中 前面 的 时间段 存在 重叠 用 0 标识 该行 否则 表示 当 前行 与 同组 中 前面 的 时间段 不存在 重叠 用 1 标识 该行 将 游标 遍历 结果 存储 在 临时 表 t 中 t 只 比 原 表 多了 broken 字段 用于 存储 所 在行 是否 需要 合并 的 标识 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp broken nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 10 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 11 01 nbsp nbsp nbsp 0 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 10 01 nbsp nbsp nbsp 0 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 01 03 2018-01-03 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 nbsp nbsp nbsp 4 2018-01-01 01 03 02 2018-01-01 01 12 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 nbsp nbsp nbsp 5 2018-01-01 01 11 02 2018-01-01 01 12 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 nbsp nbsp nbsp 6 2018-01-01 01 15 02 2018-01-01 01 16 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 nbsp nbsp nbsp 7 2018-01-01 01 01 03 2018-01-01 01 11 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 nbsp nbsp nbsp 8 2018-01-01 23 01 03 2018-01-02 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 nbsp nbsp nbsp 1 2018-01-05 01 01 01 2018-01-10 01 01 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 nbsp nbsp nbsp 2 2018-01-05 01 01 01 2018-01-06 01 01 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 nbsp nbsp nbsp 3 2018-01-06 01 01 01 2018-01-06 02 01 01 nbsp nbsp nbsp 1 15 rows in set 0.00 sec nbsp nbsp nbsp nbsp 临时 表 tmp_s 存储 合 并行 后 的 结果 除了 原有 的 四列 外 该 表 还 增加了 表示 开始 时间 和 结束 时间 之间 跨越 天数 的 一列 在 生成 该 表 数据 的 查询 语 句中 case when flag flag then rn rn+broken when flag flag then rn broken end nbsp nbsp nbsp nbsp 这句 的 含义 是 按 房间 和 用户 分组 flag 相同 的 表示 为 同一 组 并且 累加 同一 组 中 的 broken 因为 需要 合 并行 的 broken 0 所以 所有 需要 合 并行 的 累加 broken 都是 1 外层 查询 就按 这 三列 group by min s max e datediff max e min s 1 分别 得到 合并 后 的 开始 时间 结束 时间 和 跨越 天数 nbsp nbsp nbsp nbsp 然 后用 下面 的 查询 取得 最大 跨越 天数 select max i from tmp_s nbsp nbsp nbsp nbsp 最后 将 tmp_s 与 数字 辅助 表 连接 进行 跨 天 时间段 的 拆分 并将 拆分 后 的 结果 存入 临时 表 t1 nbsp nbsp nbsp nbsp 本 过程 使用 游标 仅 扫描 一遍 原始 数据表 将 中间 处理结果 存储 到 内存 临时 表 中 对于 处理 重叠 问题 具有 一定 的 通用性 之所以 用 到了 三个 临时 表 是为了 增加 代码 的 可读性 每步 产生 的 中间 结果 都 存储 于 内存 临时 表 逻辑 比较 清晰 在 性能 优 化时 也要 进行 可读性 灵活性 易 维护 性 等 多方面 权衡 避免 优化 强迫症 本例 是 可以 不用 写 三个 临时 表 的 去掉 一个 临时 表 可能 提高 些许 性能 但 若将 此 复杂 的 处理 步骤 合 并为 单一 查询 必然 使 sql 语句 变得 极为 晦涩 难懂 更 不易 维护 最终 结果是 得不偿失 nbsp nbsp nbsp nbsp 此 存储 过程 在 u_room_log 表 上 执行 生成 2557836行 数据 用时 2分 26秒 这是 一个 可以 接受 的 性能 度量 mysql&gt set max_heap_table_size 268435456 query ok 0 rows affected 0.00 sec mysql&gt set tmp_table_size 268435456 query ok 0 rows affected 0.00 sec mysql&gt call sp_overlap query ok 2557836 rows affected 2 min 26.36 sec 三 改进 取得 活跃 时段 的 算法 nbsp nbsp nbsp nbsp 经 过了 前 两步 的 数据处理 得到 了 结果 集 t1 其中 同一 房间 同一 用户 不存在 重叠 时间段 包括 开始 和 结束 的 两个 时间 点 也 不 重合 并且 每行 的 开始 时间 和 结束 时间 都不 跨 天 下面 要 依据 活跃 时段 的 定义 以 t1 作为 输入 找到 不同 用户 的 重叠 时间段 这里 使 用了 最小 范围 和 正负 计数器 两种 不同 算法 来 实现 但在 大 数据量 的 生产 环境 中 只有 后者 在 性 能上 是 可行 的 1. 最小 范围 算法 表 连接 nbsp nbsp nbsp nbsp 该 算法 步骤 如下 1 将 进出 同一 房间 的 所有 时间 点 不分 用户 统一 排序 例如 roomid 1 的 进出 房间 记录 如下 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp nbsp nbsp 这 步 处理 完成后 的 输出 为 roomid timepoint nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 2018-01-01 01 01 01 nbsp nbsp nbsp 1 2018-01-01 01 01 02 nbsp nbsp nbsp 1 2018-01-01 01 01 05 nbsp nbsp nbsp 1 2018-01-01 01 01 05 nbsp nbsp nbsp 1 2018-01-01 01 02 05 nbsp nbsp nbsp 1 2018-01-01 01 11 01 nbsp nbsp nbsp 1 2018-01-01 01 11 02 nbsp nbsp nbsp 1 2018-01-01 01 11 05 2 对于 上 一步 输出 中 同一 roomid 的 数据 将 当 前行 的 时间 点 作为 结束 时间 前 一行 的 时间 点 作为 开始 时间 并且 过滤掉 开始 时间 为 空 或 开始 时间 等于 结束 时间 的 数据 输出 为 每个 房间 的 最小 时间 范围 间隔 例如 roomid 1 的 最小 时间 范围 间隔 为 roomid starttime nbsp nbsp nbsp nbsp nbsp endtime nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 01 02 nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 1 2018-01-01 01 02 05 2018-01-01 01 11 01 nbsp nbsp nbsp 1 2018-01-01 01 11 01 2018-01-01 01 11 02 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp nbsp nbsp 这 步 是 算法 的 核心 实际上 就是 把 同一 房间 的 所有 进出 时间 点 串行化 到 一个 连续 的 时间轴 上 输出 的 每个 时间段 首尾相接 但不 重叠 3 将上 一步 的 输出 与 t1 表 做 内 连接 如果 用户 的 在线 时间 和 最小 范围 重叠 就将 重叠 的 最小 范围 和 userid roomid 输出 结果 包 含了 某个 房间 某个 用户 一个 或者 多个 的 最小 范围 例如 roomid 1 的 房间 每个 用户 对应 的 最小 时间 范围 间隔 为 roomid userid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 01 02 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 2 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 3 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 02 05 2018-01-01 01 11 01 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 4 按 上 一步 输出 中 的 roomid 和 最小 时间 范围 分组 过 滤出 每组 中 userid 个数 大于 1 的 数据 结果 为 每个 房间 对应 的 活跃 时间段 例如 roomid 1 的 房间 输出 为 roomid s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp c nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 01 05 2 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 02 05 2 5 统计 每个 房间 每天 活跃 时段 内 的 最大 人数 并 汇总 活跃 时长 舍入 到 分钟 例如 roomid 1 的 房间 输出 为 roomid dt nbsp nbsp nbsp nbsp ts nbsp c nbsp nbsp nbsp nbsp nbsp 1 2018-01-01 nbsp nbsp 1 nbsp nbsp 2 nbsp nbsp nbsp nbsp 下面 是 实现 最小 范围 算法 的 存储 过程 drop procedure if exists sp_active_duration delimiter create procedure sp_active_duration nbsp begin nbsp nbsp nbsp declare done int default 0 nbsp nbsp nbsp nbsp nbsp declare v_roomid bigint nbsp nbsp nbsp declare v_start datetime nbsp nbsp nbsp declare v_end datetime nbsp nbsp nbsp drop table if exists tmp_time_point nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp create temporary table tmp_time_point nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp timepoint datetime nbsp nbsp engine memory nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into tmp_time_point select roomid s from t1 nbsp nbsp insert into tmp_time_point select roomid e from t1 nbsp nbsp nbsp nbsp nbsp nbsp select roomid date s dt round sum timestampdiff second s e 60 ts max c c&nbsp nbsp nbsp nbsp from select roomid s e count distinct userid c&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select distinct v6.roomid v6.userid starttime s endtime e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select distinct roomid cast starttime as datetime starttime cast endtime as datetime endtime&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select if roomid roomid d as starttime d timepoint roomid roomid p.roomid p.timepoint endtime nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from tmp_time_point p select d roomid 1 vars nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp order by roomid timepoint v4&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where starttime and date starttime date endtime and starttime lt gt endtime v5&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp inner join t1 v6 on v5.starttime between v6.s and v6.e and v5.endtime between v6.s and v6.e and v5.roomid v6.roomid v6&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp group by roomid s e having count distinct userid gt 1 v7&nbsp nbsp nbsp nbsp group by roomid date s nbsp end delimiter nbsp nbsp nbsp nbsp tmp_time_point 表 即为 步骤 1 的 输出 结果 mysql 限制 在 一条 查询 中 只能 引用 临时 表 一次 否则 会报 error 1137 hy000 can t reopen table t1 错误 所以 生成 tmp_time_point 表 数据 时 执 行了 两次 insert 语句 中间 结果 集 v5 v6 v7 分别为 步骤 2 步骤 3 和 步骤 4 的 输出 结果 nbsp nbsp nbsp nbsp 最小 范围 算法 获取 活跃 时段 的 逻辑 没问题 但在 第 3 步骤 中 需要 表 关联 当 数据量 很大 时 这 步 需要 花费 非常 多 的 时间 因为 要 扫描 大量 数据 行 存储 过程中 最后 的 select 语句 在 u_room_log 表 上 的 执行计划 如下 mysql&gt explain select roomid date s dt round sum timestampdiff second s e 60 ts max c c&nbsp nbsp nbsp gt nbsp from select roomid s e count distinct userid c&nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp from select distinct v6.roomid v6.userid greatest s starttime s least e endtime e nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select distinct roomid cast starttime as datetime starttime cast endtime as datetime endtime&nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select if roomid roomid d nbsp as starttime d timepoint roomid roomid p.roomid p.timepoint endtime nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from tmp_time_point p select d roomid 1 vars nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp order by roomid timepoint v4&nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where starttime and date starttime date endtime and starttime lt gt endtime v5&nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp inner join t1 v6 on v5.starttime between v6.s and v6.e and v5.endtime between v6.s and v6.e and v5.roomid v6.roomid v6&nbsp nbsp nbsp gt nbsp nbsp nbsp nbsp nbsp group by roomid s e having count distinct userid gt 1 v7&nbsp nbsp nbsp gt nbsp group by roomid date s nbsp id select_type table nbsp nbsp nbsp partitions type nbsp possible_keys key nbsp nbsp nbsp nbsp key_len ref nbsp nbsp nbsp nbsp nbsp nbsp rows nbsp nbsp nbsp filtered extra nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 primary nbsp nbsp lt derived2&gt null nbsp nbsp nbsp all nbsp nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp 1308213650 nbsp 100.00 using temporary nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2 derived nbsp nbsp lt derived3&gt null nbsp nbsp nbsp all nbsp nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp 1308213650 nbsp 100.00 using filesort nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 3 derived nbsp nbsp v6 nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp nbsp roomid nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2557836 nbsp 100.00 using where using temporary nbsp 3 derived nbsp nbsp lt derived4&gt null nbsp nbsp nbsp ref nbsp nbsp lt auto_key0&gt nbsp lt auto_key0&gt 9 nbsp nbsp nbsp test.v6.roomid nbsp nbsp nbsp 41436 nbsp nbsp 1.23 using where using index nbsp nbsp nbsp 4 derived nbsp nbsp lt derived5&gt null nbsp nbsp nbsp all nbsp nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp 5115672 nbsp nbsp 81.00 using where using temporary nbsp 5 derived nbsp nbsp lt derived6&gt null nbsp nbsp nbsp system null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 1 nbsp 100.00 using filesort nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 5 derived nbsp nbsp p nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp all nbsp nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp 5115672 nbsp 100.00 null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 6 derived nbsp nbsp null nbsp nbsp nbsp null nbsp nbsp nbsp null nbsp null nbsp nbsp nbsp nbsp nbsp null nbsp nbsp nbsp nbsp null nbsp nbsp null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp null nbsp nbsp null no tables used nbsp nbsp nbsp nbsp nbsp nbsp nbsp 8 rows in set 5 warnings 0.01 sec nbsp nbsp nbsp nbsp 可有 看到 步骤 3 需要 关联 两个 几百 万行 的 大 表 因此在 u_room_log 表 上 执行 sp_active_duration 过程 没有 等到 出 结果 2. 正负 计数器 算法 一次 扫描 nbsp nbsp nbsp nbsp 与 重叠 时间段 优化 思想 类似 我们 希望 只 扫描 一遍 表 数据 去掉 表 关联 以 提高 性能 实际上 经过 sp_overlap 过程 处理 后 可以用 一种 高效 的 方式 得到 活跃 时段 该 算法 的 核心 思想 是 将 所有 的 进出 时间 点 统一 排序 同时 记录 每个 时间 点 的 进出 用户数 这样 我们 可以 将 在线 时间 分成 多个 互斥 的 时间段 并且 利用 当前 时间 点 前面 的 所有 累计 进出 用户数 作为 前 一个时间 点到 当前 时间 点 的 重叠 度 也 即 不同 用户数 用户 进入 房间 标 记为 1 离开 房间 标 记为 1 因此 不妨 称之为 正负 计数器 算法 具体步骤 如下 1 将同 一 房间 的 所有 进入 时间 点 和 退出 时间 点 合 并成 一列 将 进入 时间 标 记为 1 退出 时间 标 记为 1 实际上 1 表示 在 对应 的 时间 点 有 一个 用户 进入 1 表示 在 对应 的 时间 点 有 一个 用户 退出 这 步 处理 后 roomid 1 的 记录 变为 roomid timepoint nbsp nbsp nbsp nbsp nbsp type nbsp nbsp nbsp 1 2018-01-01 01 01 01 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 02 05 nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 01 nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 05 nbsp 1 2 按 房间 和 时间 点 分组 对 标志 位 汇总 聚合 目的 是 去除 重复 的 时间 点 重复 时间 点 表示 在 同一 秒 有 多个 用户 进入 或者 退出 或者 进入 退出 同一个 房间 汇总 的 目的 就是 确 定在 该 时间 点 最终 进出 的 用户数 这一步 是 必须 的 原因 有 两个 1. 我们 必须 保证 对于 一个 房间 每个 时间 点 是 唯一 的 2. 必须 确定 某一时间 点 的 进出 方向 和 进出 数量 这两个 点 是 保证 算法 成立 的 充要条件 出于 同样 的 理由 在 拆分 跨 天 记录 时 为 保持 时间 点 的 唯一性 起止 时间 相差 一秒 这 步 处理 后 roomid 1 的 记录 变为 roomid timepoint nbsp nbsp nbsp nbsp nbsp type nbsp nbsp nbsp 1 2018-01-01 01 01 01 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 nbsp nbsp 0 nbsp nbsp nbsp 1 2018-01-01 01 02 05 nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 01 nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 05 nbsp 1 3 按 房间 分组 时间 点 排序 取得 当前 时间 点 的 前 一个时间 点 对应 的 进出 用户数 如果 没有 前 一个时间 点 说明 是 该 房间 的 第一次 进入 前 一个时间 点 对应 的 进出 用户数 设为 0 这 步 处理 后 的 记录 roomid 1 变为 roomid timepoint nbsp nbsp nbsp nbsp nbsp type prevtype nbsp nbsp nbsp 1 2018-01-01 01 01 01 nbsp nbsp 1 nbsp nbsp nbsp nbsp 0 nbsp nbsp nbsp 1 2018-01-01 01 01 02 nbsp nbsp 1 nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 05 nbsp nbsp 0 nbsp nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 02 05 nbsp 1 nbsp nbsp nbsp nbsp 0 nbsp nbsp nbsp 1 2018-01-01 01 11 01 nbsp 1 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 02 nbsp nbsp 1 nbsp nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 05 nbsp 1 nbsp nbsp nbsp nbsp 1 4 取 当前 时间 点 的 前 一个时间 点 作为 起始 时间 当前 时间 点 作为 终止 时间 将 房间 的 在线 时间 区间 划 分成 互斥 时段 用 当前 时间 点 前面 的 所有 累计 进出 用户数 作为 该 时段 的 重叠 度 这 步 处理 后 roomid 1 的 记录 如下 rn 即为 starttime 和 endtime 这段 时间内 的 不同 用户数 roomid starttime nbsp nbsp nbsp nbsp nbsp endtime nbsp nbsp nbsp nbsp nbsp nbsp rn nbsp nbsp nbsp nbsp 1 null nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 2018-01-01 01 01 01 nbsp nbsp 0 nbsp nbsp nbsp 1 2018-01-01 01 01 01 2018-01-01 01 01 02 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 01 02 2018-01-01 01 01 05 nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 01 05 2018-01-01 01 02 05 nbsp nbsp 2 nbsp nbsp nbsp 1 2018-01-01 01 02 05 2018-01-01 01 11 01 nbsp nbsp 1 nbsp nbsp nbsp 1 2018-01-01 01 11 01 2018-01-01 01 11 02 nbsp nbsp 0 nbsp nbsp nbsp 1 2018-01-01 01 11 02 2018-01-01 01 11 05 nbsp nbsp 1 5 按 天 统计 每个 房间 活跃 时长 重叠 度 大于 1 的 时段 汇总 并 求出 活跃 时段 的 峰值 人数 最大 重叠 度 最终 roomid 1 的 结果 如下 其中 dur 为 活跃 时长 单位 舍入 为 分钟 c 是 峰值 人数 roomid dt nbsp nbsp nbsp nbsp dur nbsp c nbsp nbsp nbsp nbsp nbsp 1 2018-01-01 nbsp nbsp 1 nbsp nbsp 2 nbsp nbsp nbsp nbsp 采用 正负 计数器 算法 后 的 sp_active_duration 如下 drop procedure if exists sp_active_duration delimiter create procedure sp_active_duration nbsp begin nbsp nbsp nbsp declare done int default 0 nbsp nbsp nbsp nbsp nbsp declare v_roomid bigint nbsp nbsp nbsp declare v_start datetime nbsp nbsp nbsp declare v_end datetime nbsp nbsp nbsp declare cur_test cursor for select roomid s e from t1 nbsp nbsp nbsp nbsp nbsp declare continue handler for not found set done 1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp drop table if exists tmp_time_point nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp create temporary table tmp_time_point nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid bigint nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp timepoint datetime nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp type smallint nbsp nbsp engine memory nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp 开 始点 1 结束 点 1 nbsp nbsp nbsp nbsp nbsp insert into tmp_time_point roomid timepoint type select roomid s 1 from t1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp insert into tmp_time_point roomid timepoint type select roomid e 1 from t1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid date s dt round sum timestampdiff second date_format s y- m- d h i s date_format e y- m- d h i s 60 ts max rn c&nbsp nbsp nbsp nbsp from select if roomid roomid d as s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp d str_to_date timepoint y- m- d h i s. f nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp p.roomid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp str_to_date timepoint y- m- d h i s. f e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp rn nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select round case when roomid roomid then rn rn+prevtype when roomid roomid then rn prevtype end rn b.prevtype roomid timepoint type nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select a.roomid timepoint type if roomid roomid type 0 prevtype roomid roomid type type&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select roomid timepoint sum type type from tmp_time_point group by roomid timepoint tmp_time_point nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid 1 rn 0 type 0 vars&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp order by roomid timepoint a b&nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp order by roomid timepoint p nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select d roomid 1 vars nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp order by roomid timepoint v4&nbsp nbsp nbsp nbsp where rn&gt 2 nbsp nbsp nbsp nbsp nbsp nbsp nbsp group by roomid date s nbsp nbsp nbsp nbsp nbsp nbsp end delimiter nbsp nbsp nbsp nbsp tmp_time_point 表 存储 步骤 1 的 结果 b v4 分 别是 步骤 3 和 步骤 4 的 输出 结果 过程中 最后 的 查询 只 扫描 一遍 tmp_time_point 表 处理 速度 大为 提高 u_room_log 表 上 sp_active_duration 过程 的 执行时间 为 1分 13秒 nbsp nbsp nbsp nbsp 为 满足 原始 需求 只需 要在 一个 会话 中 连续 调用 两个 存储 过程 即可 250万 的 业务 日志 数据 总 执行时间 约为 3分 40秒 set max_heap_table_size 268435456 set tmp_table_size 268435456 call sp_overlap call sp_active_duration 四 mysql 8 的 单 条 查询 解决方案 nbsp nbsp nbsp nbsp mysql 8 提供 了 丰富 的 窗口 函数 使 复杂 分析 查询 成为可能 更进一步 老版 mysql 的 行 级 变量 用法 已经 不再 推荐 使用 mysql&gt select a id from nums limit 1 a id nbsp nbsp nbsp 1 1 row in set 1 warning 0.00 sec mysql&gt show warnings level nbsp code message nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp warning 1287 setting user variables within expressions is deprecated and will be removed in a future release. consider alternatives set variable expression or select expression s into variables s 1 row in set 0.00 sec nbsp nbsp nbsp nbsp 没有 提供 窗口 函数 前 为了 处理 复杂 逻辑 使用 行 级 变量 也是 不得已而为之 本身 就不是 标准 sql 可读性 很差 如果 需要 换 rdbms 比 重做 一遍 还 麻烦 而 mysql 8 在 sql 功能上 已经 接近 oracle 重叠 时间段 问题 用 一句 查询 即可 解决 with c1 as nbsp 合并 同一 房间 同一 用户 的 重叠 时间段 用于 统计 峰值 人数 nbsp nbsp nbsp nbsp select distinct roomid userid min s s max e e nbsp nbsp nbsp nbsp nbsp from select roomid userid s e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp sum broken over partition by roomid userid order by s e flag nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp case when s lt max e over partition by roomid userid order by s e rows between unbounded preceding and 1 preceding then 0 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp else 1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp end as broken nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from test1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp t nbsp nbsp nbsp nbsp nbsp nbsp nbsp t nbsp nbsp nbsp nbsp group by roomid userid flag nbsp nbsp c2 as nbsp 拆分 跨 天 的 时间段 nbsp nbsp nbsp nbsp select nbsp nbsp nbsp nbsp nbsp from select roomid userid s e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from c1 nbsp nbsp nbsp nbsp nbsp nbsp nbsp where date s date e nbsp 不 跨 天 nbsp nbsp nbsp nbsp nbsp nbsp nbsp union all nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid userid nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp case when id 1 then s else date_add date s interval id-1 day end s nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp case when id m2 then e else date_add date s interval id 3600 24 1 second nbsp end e nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from select roomid userid s e id nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp max id over partition by roomid userid s m2 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from c1 select id from nums where id&lt 100 n nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp where date s lt gt date e 跨 天 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp and id lt date e date s 1 t1 t1 nbsp nbsp c3 as 在 计算 最小 范围 的 同时 计算 区间 用户数 nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid ts endtime sum prevtype over partition by roomid order by ts rn nbsp nbsp nbsp nbsp nbsp lag ts over partition by roomid order by ts starttime nbsp nbsp nbsp nbsp from nbsp nbsp nbsp nbsp nbsp select a. ifnull lag type over partition by roomid order by ts 0 prevtype nbsp nbsp nbsp nbsp nbsp from nbsp nbsp nbsp nbsp nbsp nbsp select nbsp nbsp nbsp nbsp nbsp nbsp nbsp roomid ts sum type type nbsp nbsp nbsp nbsp nbsp nbsp from nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid e ts 1 type nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from c2 nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp union all nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp select roomid s ts 1 type nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp from c2 nbsp nbsp nbsp nbsp nbsp nbsp t1 group by roomid ts nbsp nbsp nbsp nbsp nbsp a nbsp nbsp nbsp nbsp c nbsp select roomid dt round sum dur 60 ts max rn c from nbsp nbsp select roomid date starttime dt timestampdiff second starttime endtime dur rn nbsp nbsp nbsp from c3 where rn&gt 2 nbsp nbsp t group by roomid dt nbsp order by roomid dt nbsp nbsp nbsp nbsp 该 查询 处理 逻辑 和 存储 过程 完全相同 只是 大部分 复杂 工作 都 交给 窗口 函数 完 成了 写法 更 简练 但 执行时间 没有 存储 过程 快 相同 环境 下 with 查询 在 u_room_log 上 的 执行时间 为 4分 10 秒左右 比 自定义 的 存储 过程 执行 还慢 半分钟 